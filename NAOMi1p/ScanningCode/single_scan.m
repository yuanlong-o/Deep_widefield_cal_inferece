function scan_img = single_scan(neur_vol, psf_sz, psf2, varargin)

% scan_img = scan_volume(neur_vol, psf, varargin)
%
% Scan a 3D volume with a given point-spread function. This function takes
% in a neural volume (as generated by "simulate_neural_vol_v*.m"), a
% point-spread function, and a number of other optional scanning parameters
% in order to simulate the images resulting from a two-photon scan of the
% volume with the given PSF. Inputs to this function are:
%   - neur_vol - 3D volume where each voxel contains the fluorescence
%   - psf      - 3D array containing the intensity of the point-spread
%                function
%   - z_sub    - OPTIONAL speed-up parameter that scans multiple slices
%                simultaneously, reducing the number of convolutions needed
%                by a factor of 'z_sub'
%
% The output is
%   - scan_img - The scanned image - i.e. the return fluorescence from the
%                point-spread function with no noise (photon or electronic)
%
% 2016 - Adam Charles


% modified by YZ. last update: 9/18/2021.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Parse Inputs

if nargin > 3
    z_sub = varargin{1};
else
    z_sub = 1;
end

if nargin > 4
    freq_opt = varargin{2};
else
    freq_opt = false;
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Calculate and sum convolutions

if z_sub > 1                                                               % For time considerations, can pre-sum every few slices
    N_slce    = ceil(size(neur_vol,3)/z_sub);                              % Figure out how many slices after pre-summing
    neur_vol2 = neur_vol(:,:,1:z_sub:z_sub*N_slce);                        % Initialize the new volume
    if ~freq_opt
        psf   = psf2(:,:,1:z_sub:z_sub*N_slce);                            % Initialize the new point-spread function
    end
    for kk = 2:z_sub
        slcs                = kk:z_sub:min(z_sub*N_slce, size(neur_vol,3));% Slices to add
        Nz                  = numel(slcs);                                 % Figure out how many slices in the kk^th sub-sampling (in case 
        neur_vol2(:,:,1:Nz) = neur_vol2(:,:,1:Nz) + neur_vol(:,:,slcs);    % Iteratively add in the volue slices
        if ~freq_opt
            psf(:,:,1:Nz)   = psf(:,:,1:Nz) + psf2(:,:,slcs);              % Iteratively add in the PSF slices
        end
    end
end

if freq_opt
    sz = size(psf2);                                                       % Get the sizes of the post-convolution array
    scan_img = ifft(ifft(sum(fft(fft(neur_vol2, sz(1), 1), sz(2), 2).*psf2,3), ...
                                              [], 1), [], 2, 'symmetric'); % Perform convolution in the Fourier domain in both NON-axial dimensions

    y_ix     = ceil((psf_sz(1)-1)/2) + [1,size(neur_vol2,1)];              % Get dim 1 size of image (basically cropping the convolution
    y_jx     = ceil((psf_sz(2)-1)/2) + [1,size(neur_vol2,2)];              % Get dim 2 sizes of image (basically cropping the convolution
    scan_img = scan_img(y_ix(1):y_ix(2),y_jx(1):y_jx(2));                  % Crop the image
else
    scan_img = 0;
    for ll = 1:size(psf2,3) % depth tiling
        scan_img = scan_img + conv2(neur_vol(:,:,ll),psf2(:,:,ll),'same');% Iteratively add in the scanned layers.
    end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
